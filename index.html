<html lang="ja">
    <head>
        <meta charset="utf-8" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1, viewport-fit=cover"
        />
        <meta name="theme-color" content="#e0e0e0" />
        <title>防音窓実験室 Noise Lab</title>
        <style>
            :root {
                --bg: #e0e0e0;
                --text: #445;
                --muted: #7a7a7a;
                --shadow-dark: #bebebe;
                --shadow-light: #ffffff;
                --accent: #3a86ff;
                --ok: #33c27f;
                --ng: #ff5a5f;
                --card-radius: 18px;
                --btn-radius: 16px;
                --shadow-lg: 14px;
                --shadow-md: 10px;
                --shadow-sm: 6px;
            }
            * {
                box-sizing: border-box;
            }
            html,
            body {
                margin: 0;
                padding: 0;
                background: var(--bg);
                color: var(--text);
                font-family:
                    -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
                    "Hiragino Sans", "Noto Sans JP", "Helvetica Neue", Arial,
                    "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",
                    sans-serif;
                -webkit-font-smoothing: antialiased;
                text-rendering: optimizeLegibility;
            }

            /* Neumorphism */
            .nm-raised {
                background: var(--bg);
                border-radius: var(--card-radius);
                box-shadow:
                    var(--shadow-lg) var(--shadow-lg)
                        calc(var(--shadow-lg) * 1.5) var(--shadow-dark),
                    calc(var(--shadow-lg) * -1) calc(var(--shadow-lg) * -1)
                        calc(var(--shadow-lg) * 1.5) var(--shadow-light);
            }
            .nm-inset {
                background: var(--bg);
                border-radius: var(--card-radius);
                box-shadow:
                    inset var(--shadow-md) var(--shadow-md)
                        calc(var(--shadow-md) * 1.6) var(--shadow-dark),
                    inset calc(var(--shadow-md) * -1)
                        calc(var(--shadow-md) * -1) calc(var(--shadow-md) * 1.6)
                        var(--shadow-light);
            }
            .chip {
                font-size: 12px;
                color: var(--muted);
                padding: 7px 10px;
                border-radius: 999px;
                background: var(--bg);
                box-shadow:
                    6px 6px 12px var(--shadow-dark),
                    -6px -6px 12px var(--shadow-light);
                line-height: 1;
            }

            /* App frame */
            .app {
                min-height: 100svh;
                max-width: 1200px;
                margin: 0 auto;
                display: grid;
                grid-template-rows: auto auto 1fr auto;
                gap: 14px;
                padding: 16px 16px 10px;
            }

            /* Header: title + compact BT */
            .topbar {
                display: flex;
                align-items: center;
                gap: 10px;
                flex-wrap: wrap;
            }
            .topbar h1 {
                margin: 0;
                font-size: 20px;
                font-weight: 700;
                letter-spacing: 0.2px;
                text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.6);
            }
            .topbar .spacer {
                flex: 1 1 auto;
            }
            .bt-chip {
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 6px 8px;
                border-radius: 999px;
                background: var(--bg);
                box-shadow:
                    6px 6px 12px var(--shadow-dark),
                    -6px -6px 12px var(--shadow-light);
                color: var(--muted);
                white-space: nowrap;
                line-height: 1;
            }
            .bt-chip .dot {
                width: 9px;
                height: 9px;
                border-radius: 50%;
                box-shadow:
                    inset 2px 2px 4px rgba(0, 0, 0, 0.08),
                    inset -2px -2px 4px rgba(255, 255, 255, 0.8),
                    0 0 0 2px rgba(0, 0, 0, 0.03);
            }
            .bt-chip .dot.ok {
                background: radial-gradient(
                    circle at 30% 30%,
                    #b8ffd8,
                    #33c27f
                );
            }
            .bt-chip .dot.ng {
                background: radial-gradient(
                    circle at 30% 30%,
                    #ffd8d8,
                    #ff5a5f
                );
            }
            .bt-chip .lbl {
                font-size: 12px;
                font-weight: 600;
                color: #444;
            }
            .bt-chip .btn {
                appearance: none;
                border: 0;
                background: linear-gradient(145deg, #e7e7e7, #d9d9d9);
                border-radius: 999px;
                padding: 5px 8px;
                font-size: 12px;
                font-weight: 600;
                color: #333;
                cursor: pointer;
                box-shadow:
                    var(--shadow-sm) var(--shadow-sm) var(--shadow-md)
                        var(--shadow-dark),
                    calc(var(--shadow-sm) * -1) calc(var(--shadow-sm) * -1)
                        var(--shadow-md) var(--shadow-light);
            }
            .bt-chip .btn:active {
                box-shadow:
                    inset var(--shadow-sm) var(--shadow-sm)
                        calc(var(--shadow-sm) * 1.4) var(--shadow-dark),
                    inset calc(var(--shadow-sm) * -1)
                        calc(var(--shadow-sm) * -1) calc(var(--shadow-sm) * 1.4)
                        var(--shadow-light);
            }
            .bt-chip .btn:focus-visible {
                outline: 2px solid rgba(58, 134, 255, 0.75);
                outline-offset: 2px;
            }

            /* Metrics: single row (dB chip + subtle sparkline) */
            .metrics {
                display: grid;
                grid-template-columns: auto 1fr;
                gap: 10px;
                align-items: center;
                padding: 8px 10px;
            }
            .db-chip {
                display: grid;
                gap: 4px;
                padding: 10px 12px;
                min-width: 200px;
                justify-items: center;
            }
            .db-chip .label {
                font-size: 11px;
                color: var(--muted);
            }
            .db-chip .value {
                font-variant-numeric: tabular-nums;
                font-weight: 800;
                font-size: 30px;
                line-height: 1.1;
                color: #3f3f3f;
                text-shadow: 1px 1px 0 rgba(255, 255, 255, 0.7);
            }
            .spark {
                padding: 8px 10px;
                display: grid;
                align-items: center;
            }
            canvas#spectrum {
                width: 100%;
                height: 56px;
                display: block;
                border-radius: 10px;
                opacity: 0.7;
            }
            @media (max-width: 560px) {
                .metrics {
                    grid-template-columns: 1fr;
                }
                .db-chip {
                    min-width: 0;
                }
            }
            @media (min-width: 900px) and (orientation: landscape) {
                canvas#spectrum {
                    height: 68px;
                }
            }

            /* Sound panel (main 7割)。影崩れ防止のため十分な内側余白を確保 */
            .sound-panel {
                padding: 12px;
                display: flex;
                flex-direction: column;
                min-height: 0;
            }
            .sound-scroll {
                overflow: auto;
                padding: 16px; /* 外周に余白を設け、ボタンのbox-shadowが切れないようにする */
            }
            .grid {
                display: grid;
                gap: 14px;
                grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
                align-items: start;
            }

            /* Buttons: light raised -> inset when active. 影を軽量化し、崩れにくく */
            .nm-btn {
                appearance: none;
                border: none;
                width: 100%;
                background: var(--bg);
                border-radius: var(--btn-radius);
                box-shadow:
                    8px 8px 16px var(--shadow-dark),
                    -8px -8px 16px var(--shadow-light);
                padding: 14px;
                cursor: pointer;
                color: var(--text);
                text-align: left;
                transition: box-shadow 0.15s ease;
                min-height: 76px;
            }
            .nm-btn.is-active,
            .nm-btn:active {
                box-shadow:
                    inset 6px 6px 12px var(--shadow-dark),
                    inset -6px -6px 12px var(--shadow-light);
            }
            .nm-btn:focus-visible {
                outline: 2px solid rgba(58, 134, 255, 0.75);
                outline-offset: 3px;
                border-radius: 14px;
            }

            .sound-btn {
                display: grid;
                grid-template-columns: 36px 1fr;
                gap: 12px;
                align-items: center;
            }
            .sound-btn .icon {
                width: 36px;
                height: 36px;
                display: grid;
                place-items: center;
                font-size: 26px;
                line-height: 1;
            }
            .sound-btn .text {
                display: flex;
                flex-direction: column;
                gap: 3px;
                min-width: 0;
            }
            .sound-btn .title {
                font-weight: 700;
                line-height: 1.2;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }
            .sound-btn .desc {
                font-size: 12px;
                color: var(--muted);
                line-height: 1.25;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            footer.note {
                font-size: 11px;
                color: var(--muted);
                text-align: center;
                padding-bottom: 6px;
            }
            @media (prefers-reduced-motion: reduce) {
                .nm-btn {
                    transition: none;
                }
            }
        </style>
    </head>
    <body>
        <div class="app">
            <header class="topbar">
                <span class="chip" aria-hidden="true">PWA</span>
                <h1>防音窓実験室 Noise Lab</h1>
                <div class="spacer"></div>
                <div class="bt-chip" aria-label="Bluetoothスピーカー接続状態">
                    <span id="btDot" class="dot ng" aria-hidden="true"></span>
                    <span id="btLabel" class="lbl">未接続</span>
                    <button
                        id="connectBtn"
                        class="btn"
                        type="button"
                        aria-label="スピーカーに接続"
                    >
                        接続
                    </button>
                </div>
            </header>

            <!-- dB + スパークライン（横並び、控えめ） -->
            <section class="nm-raised metrics" aria-label="音量とスペクトラム">
                <div class="nm-inset db-chip">
                    <div class="label">相対音量 [dBFS]</div>
                    <div id="dbValue" class="value">--.- dB</div>
                </div>
                <div class="nm-inset spark">
                    <canvas
                        id="spectrum"
                        aria-label="スペクトラム（参考表示）"
                        role="img"
                    ></canvas>
                </div>
            </section>

            <!-- メイン：再生ボタン（約7割） -->
            <section
                class="nm-raised sound-panel"
                aria-label="生活音の再生ボタン"
            >
                <div class="sound-scroll">
                    <div class="grid">
                        <button
                            class="nm-btn sound-btn"
                            data-sound="voice"
                            aria-pressed="false"
                        >
                            <div class="icon" aria-hidden="true">💬</div>
                            <div class="text">
                                <div class="title">話し声</div>
                                <div class="desc">
                                    中域中心の断続的な声の感じ
                                </div>
                            </div>
                        </button>
                        <button
                            class="nm-btn sound-btn"
                            data-sound="tv"
                            aria-pressed="false"
                        >
                            <div class="icon" aria-hidden="true">📺</div>
                            <div class="text">
                                <div class="title">テレビ音</div>
                                <div class="desc">広帯域のにぎやかな音</div>
                            </div>
                        </button>
                        <button
                            class="nm-btn sound-btn"
                            data-sound="construction"
                            aria-pressed="false"
                        >
                            <div class="icon" aria-hidden="true">🚧</div>
                            <div class="text">
                                <div class="title">工事音</div>
                                <div class="desc">低音の打撃＋騒音バースト</div>
                            </div>
                        </button>
                        <button
                            class="nm-btn sound-btn"
                            data-sound="laundry"
                            aria-pressed="false"
                        >
                            <div class="icon" aria-hidden="true">🧺</div>
                            <div class="text">
                                <div class="title">洗濯機</div>
                                <div class="desc">低周波モーター＋揺れ</div>
                            </div>
                        </button>
                        <button
                            class="nm-btn sound-btn"
                            data-sound="rain"
                            aria-pressed="false"
                        >
                            <div class="icon" aria-hidden="true">🌧️</div>
                            <div class="text">
                                <div class="title">雨音</div>
                                <div class="desc">高域成分のパラパラ音</div>
                            </div>
                        </button>
                        <button
                            class="nm-btn sound-btn"
                            data-sound="traffic"
                            aria-pressed="false"
                        >
                            <div class="icon" aria-hidden="true">🚗</div>
                            <div class="text">
                                <div class="title">交通騒音</div>
                                <div class="desc">低〜中域の連続的なノイズ</div>
                            </div>
                        </button>
                    </div>
                </div>
            </section>

            <footer class="note">
                表示dBは相対値（dBFS）。実際の騒音計ではありません。OSのBluetooth設定はブラウザから直接開けません。
            </footer>
        </div>

        <script>
            // Audio + Analyzer
            let audioCtx;
            let masterGain, analyser, dest, mediaOutEl;
            let currentSoundStop = null;

            function ensureAudio() {
                if (audioCtx) return;
                audioCtx = new (window.AudioContext ||
                    window.webkitAudioContext)();
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.9;

                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.85;

                masterGain.connect(analyser);

                dest = audioCtx.createMediaStreamDestination();
                analyser.connect(dest);
                mediaOutEl = new Audio();
                mediaOutEl.autoplay = true;
                mediaOutEl.srcObject = dest.stream;
                mediaOutEl.play().catch(() => {});
            }

            function createNoiseBuffer(lenSec = 2) {
                const sr = audioCtx.sampleRate;
                const length = Math.max(1, Math.floor(sr * lenSec));
                const buffer = audioCtx.createBuffer(1, length, sr);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < length; i++)
                    data[i] = Math.random() * 2 - 1;
                return buffer;
            }
            function makeBufferSource(buffer, loop = true) {
                const src = audioCtx.createBufferSource();
                src.buffer = buffer;
                src.loop = loop;
                return src;
            }

            // --- Sound file playback ---
            const SOUND_FILES = {
                voice: "sounds/voice.mp3",
                tv: "sounds/tv.mp3",
                construction: "sounds/construction.mp3",
                laundry: "sounds/laundry.mp3",
                rain: "sounds/rain.mp3",
                traffic: "sounds/traffic.mp3",
            };
            const audioBuffers = {}; // Cache for decoded audio data

            // Function to load and decode a sound file
            async function loadSound(kind) {
                if (audioBuffers[kind]) {
                    return audioBuffers[kind]; // Return from cache
                }
                const filePath = SOUND_FILES[kind];
                if (!filePath) {
                    console.error(`Sound kind "${kind}" not found in SOUND_FILES.`);
                    return null;
                }
                try {
                    const response = await fetch(filePath);
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                    const arrayBuffer = await response.arrayBuffer();
                    const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                    audioBuffers[kind] = audioBuffer; // Store in cache
                    return audioBuffer;
                } catch (e) {
                    console.error(`Error loading sound "${kind}" from ${filePath}:`, e);
                    alert(`音声ファイル「${filePath}」の読み込みに失敗しました。`);
                    return null;
                }
            }

            // In this new implementation, currentSoundStop will hold the active AudioBufferSourceNode
            async function startSound(kind) {
                ensureAudio();
                await audioCtx.resume();
                stopSound(); // Stop any currently playing sound

                const audioBuffer = await loadSound(kind);
                if (!audioBuffer) {
                    // Deselect the button if loading fails
                    const activeBtn = document.querySelector(`.sound-btn[data-sound="${kind}"]`);
                    if (activeBtn) {
                        activeBtn.classList.remove("is-active");
                        activeBtn.setAttribute("aria-pressed", "false");
                    }
                    return;
                }

                const source = audioCtx.createBufferSource();
                source.buffer = audioBuffer;
                source.loop = true;
                source.connect(masterGain);
                source.start(0);

                currentSoundStop = source; // Store the source node to stop it later
            }

            function stopSound() {
                if (currentSoundStop) {
                    try {
                        // stop() can be called only once
                        currentSoundStop.stop(0);
                        currentSoundStop.disconnect();
                    } catch (e) {
                        // Ignore errors, e.g., if the node was already stopped
                    }
                    currentSoundStop = null;
                }
            }

            // UI wiring
            const btns = Array.from(document.querySelectorAll(".sound-btn"));
            btns.forEach((btn) => {
                btn.addEventListener("click", () => {
                    const kind = btn.dataset.sound;
                    const isActive = btn.classList.contains("is-active");
                    btns.forEach((b) => {
                        b.classList.remove("is-active");
                        b.setAttribute("aria-pressed", "false");
                    });
                    if (isActive) stopSound();
                    else {
                        btn.classList.add("is-active");
                        btn.setAttribute("aria-pressed", "true");
                        startSound(kind);
                    }
                });
            });

            // dB + subtle sparkline
            const dbEl = document.getElementById("dbValue");
            const canvas = document.getElementById("spectrum");
            const ctx2d = canvas.getContext("2d");

            function resizeCanvas() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = Math.floor(rect.width * dpr);
                canvas.height = Math.floor(rect.height * dpr);
                ctx2d.setTransform(dpr, 0, 0, dpr, 0, 0);
            }
            new ResizeObserver(resizeCanvas).observe(canvas);
            resizeCanvas();

            function draw() {
                requestAnimationFrame(draw);
                const rect = canvas.getBoundingClientRect();
                ctx2d.clearRect(0, 0, rect.width, rect.height);
                if (!analyser) return;

                // dBFS
                const timeArr = new Float32Array(analyser.fftSize);
                analyser.getFloatTimeDomainData(timeArr);
                let sum = 0;
                for (let i = 0; i < timeArr.length; i++)
                    sum += timeArr[i] * timeArr[i];
                const rms = Math.sqrt(sum / timeArr.length) || 1e-9;
                const dbfs = 20 * Math.log10(rms);
                dbEl.textContent = `${dbfs.toFixed(1)} dB`;

                // Sparkline（控えめ）
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteFrequencyData(dataArray);

                const w = rect.width,
                    h = rect.height;
                const points = 60;
                const step = Math.max(1, Math.floor(bufferLength / points));

                const vals = [];
                let prev = 0;
                for (let i = 0; i < points; i++) {
                    let acc = 0;
                    for (let j = 0; j < step; j++)
                        acc += dataArray[i * step + j] || 0;
                    let v = acc / step / 255;
                    v = prev * 0.65 + v * 0.35;
                    prev = v; // smooth
                    vals.push(v);
                }

                const padX = 6,
                    padY = 6;
                const innerW = w - padX * 2,
                    innerH = h - padY * 2;
                const toX = (i) => padX + (i / (points - 1)) * innerW;
                const toY = (v) => padY + (1 - v) * innerH * 0.85;

                // area
                ctx2d.beginPath();
                ctx2d.moveTo(toX(0), toY(vals[0]));
                for (let i = 1; i < points; i++)
                    ctx2d.lineTo(toX(i), toY(vals[i]));
                ctx2d.lineTo(toX(points - 1), h - padY);
                ctx2d.lineTo(toX(0), h - padY);
                ctx2d.closePath();
                ctx2d.fillStyle = "rgba(58,134,255,0.10)";
                ctx2d.fill();

                // line
                ctx2d.beginPath();
                ctx2d.moveTo(toX(0), toY(vals[0]));
                for (let i = 1; i < points; i++)
                    ctx2d.lineTo(toX(i), toY(vals[i]));
                ctx2d.strokeStyle = "rgba(58,134,255,0.32)";
                ctx2d.lineWidth = 1.5;
                ctx2d.stroke();
            }
            draw();

            // Output device selection
            const connectBtn = document.getElementById("connectBtn");
            const btDot = document.getElementById("btDot");
            const btLabel = document.getElementById("btLabel");

            async function connectSpeaker() {
                ensureAudio();
                try {
                    if (
                        navigator.mediaDevices &&
                        "selectAudioOutput" in navigator.mediaDevices
                    ) {
                        const device =
                            await navigator.mediaDevices.selectAudioOutput();
                        if (device && device.deviceId && mediaOutEl.setSinkId) {
                            await mediaOutEl.setSinkId(device.deviceId);
                            setBtStatus(
                                true,
                                device.label || "出力デバイス選択済み",
                            );
                            return;
                        }
                    }
                    if (mediaOutEl.setSinkId) {
                        await mediaOutEl.setSinkId("default");
                        setBtStatus(true, "既定の出力に設定しました");
                    } else {
                        setBtStatus(false, "出力先選択は非対応");
                        alert(
                            "このブラウザでは出力デバイスの直接選択に未対応です。OSのBluetooth設定またはブラウザの音声出力設定からスピーカーを選択してください。",
                        );
                    }
                } catch (e) {
                    console.error(e);
                    setBtStatus(false, "接続に失敗");
                    alert(
                        "出力デバイスの選択に失敗しました。権限や接続状態をご確認ください。",
                    );
                }
            }
            function setBtStatus(connected, tip) {
                btDot.classList.toggle("ok", connected);
                btDot.classList.toggle("ng", !connected);
                btLabel.textContent = connected ? "接続済み" : "未接続";
                const chip = btLabel.closest(".bt-chip");
                if (chip)
                    chip.title =
                        tip ||
                        (connected
                            ? "音声出力がスピーカーに設定されました"
                            : "対応ブラウザで出力デバイスを選択できます");
            }
            connectBtn.addEventListener("click", connectSpeaker);

            window.addEventListener("pagehide", () => {
                stopSound();
            });
        </script>
    </body>
</html>
